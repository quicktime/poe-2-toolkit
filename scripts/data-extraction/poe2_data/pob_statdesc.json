{
  "raw": "local nk = { }\n\nlocal statDescriptor\nlocal statDescriptors = { }\nfunction loadStatFile(fileName)\n\tif statDescriptors[fileName] then\n\t\tstatDescriptor = statDescriptors[fileName]\n\t\treturn\n\tend\n\tstatDescriptor = { }\n\tstatDescriptors[fileName] = statDescriptor \n\tlocal curLang\n\tlocal curDescriptor = { }\n\tlocal order = 1\n\tlocal function processLine(line)\n\t\tlocal include = line:match('include \"Metadata/StatDescriptions/(.+)\"$')\n\t\tif include then\n\t\t\tlocal text = convertUTF16to8(getFile(\"Metadata/StatDescriptions/\"..include))\n\t\t\tfor line in text:gmatch(\"[^\\r\\n]+\") do\n\t\t\t\tprocessLine(line)\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tlocal noDesc = line:match(\"no_description ([%w_%+%-%%]+)\")\n\t\tif noDesc then\n\t\t\tstatDescriptor[noDesc] = { order = 0 }\n\t\telseif line:match(\"handed_description\") or (line:match(\"description\") and not line:match(\"_description\")) then\t\n\t\t\tlocal name = line:match(\"description ([%w_]+)\")\n\t\t\tcurLang = { }\n\t\t\tcurDescriptor = { curLang, order = order, name = name }\n\t\t\torder = order + 1\n\t\telseif not curDescriptor.stats then\n\t\t\tlocal stats = line:match(\"%d+%s+([%w_%+%-%% ]+)\")\n\t\t\tif stats then\n\t\t\t\tcurDescriptor.stats = { }\n\t\t\t\tfor stat in stats:gmatch(\"[%w_%+%-%%]+\") do\n\t\t\t\t\ttable.insert(curDescriptor.stats, stat)\n\t\t\t\t\tstatDescriptor[stat] = curDescriptor\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tlocal langName = line:match('lang \"(.+)\"')\n\t\t\tif langName then\n\t\t\t\tcurLang = { }\n\t\t\t\t--curDescriptor.lang[langName] = curLang\n\t\t\telseif not line:match('table_only') then\n\t\t\t\tlocal statLimits, quality, text, special = line:match('([%d%-#| !]+)%s*([%w_]*)%s*\"(.-)\"%s*(.*)')\n\t\t\t\tif statLimits then\n\t\t\t\t\tlocal desc = { text = escapeGGGString(text):gsub(\"\\\\([^nb])\", \"\\\\n%1\"), limit = { } }\n\t\t\t\t\tfor statLimit in statLimits:gmatch(\"[!%d%-#|]+\") do\n\t\t\t\t\t\tlocal limit = { }\n\t\t\t\t\t\t\n\t\t\t\t\t\tif statLimit == \"#\" then\n\t\t\t\t\t\t\tlimit[1] = \"#\"\n\t\t\t\t\t\t\tlimit[2] = \"#\"\n\t\t\t\t\t\telseif statLimit:match(\"^%-?%d+$\") then\n\t\t\t\t\t\t\tlimit[1] = tonumber(statLimit)\n\t\t\t\t\t\t\tlimit[2] = tonumber(statLimit)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlocal negate = statLimit:match(\"^!(-?%d+)$\")\n\t\t\t\t\t\t\tif negate then\n\t\t\t\t\t\t\t\tlimit[1] = \"!\"\n\t\t\t\t\t\t\t\tlimit[2] = tonumber(negate)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tlimit[1], limit[2] = statLimit:match(\"([%d%-#]+)|([%d%-#]+)\")\n\t\t\t\t\t\t\t\tlimit[1] = tonumber(limit[1]) or limit[1]\n\t\t\t\t\t\t\t\tlimit[2] = tonumber(limit[2]) or limit[2]\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\ttable.insert(desc.limit, limit)\n\t\t\t\t\tend\n\t\t\t\t\tfor k, v in special:gmatch(\"([%w%%_]+) (%d+)\") do\n\t\t\t\t\t\ttable.insert(desc, {\n\t\t\t\t\t\t\tk = k,\n\t\t\t\t\t\t\tv = tonumber(v) or v,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tnk[k] = v\n\t\t\t\t\tend\n\t\t\t\t\tif special:match(\"canonical_line\") then\n\t\t\t\t\t\ttable.insert(desc, {\n\t\t\t\t\t\t\tk = \"canonical_line\",\n\t\t\t\t\t\t\tv = true,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tnk[\"canonical_line\"] = true\n\t\t\t\t\tend\n\t\t\t\t\tif quality:match(\"gem_quality\") then\n\t\t\t\t\t\tdesc[quality] = true\n\t\t\t\t\t\tnk[\"gem_quality\"] = true\n\t\t\t\t\tend\n\t\t\t\t\ttable.insert(curLang, desc)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tlocal text = convertUTF16to8(getFile(\"Metadata/StatDescriptions/\"..fileName))\n\tfor line in text:gmatch(\"[^\\r\\n]+\") do\n\t\tprocessLine(line)\n\tend\n\tprint(fileName.. \" loaded. (\"..order..\" stats)\")\nend\n\nfor k, v in pairs(nk) do\n\tprint(\"'\"..k..\"' = '\"..v..\"'\")\nend\n\nlocal function matchLimit(lang, val)\n\tfor _, desc in ipairs(lang) do\n\t\tlocal match = true\n\t\tfor i, limit in ipairs(desc.limit) do\n\t\t\tif limit[1] == \"!\" then\n\t\t\t\tif val[i].min == limit[2] then\n\t\t\t\t\tmatch = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telseif (limit[2] ~= \"#\" and val[i].min > limit[2]) or (limit[1] ~= \"#\" and val[i].min < limit[1]) then\n\t\t\t\tmatch = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif match then\n\t\t\treturn desc\n\t\tend\n\tend\nend\n\nfunction describeModTags(modTags)\n\tif not modTags then\n\t\treturn \"\"\n\tend\n\n\tlocal tagsDat = dat(\"Tags\")\n\tlocal modTagsText = \"\"\n\tfor i=1,#modTags do\n\t\tlocal curModTagIndex = modTags[i]._rowIndex\n\t\tif #modTagsText > 0 then\n\t\t\tmodTagsText = modTagsText..', '\n\t\tend\n\t\tmodTagsText = modTagsText..'\"'..tagsDat:ReadCellText(curModTagIndex, 1)..'\"'\n\tend\n\treturn modTagsText\nend\n\nfunction describeStats(stats)\n\tlocal out = { }\n\tlocal orders = { }\n\tlocal descriptors = { }\n\tlocal missing = {false}\n\tfor s, v in pairs(stats) do\n\t\tif s ~= \"Type\" and statDescriptor[s] and statDescriptor[s].stats then\n\t\t\tif (v.min ~= 0 or v.max ~= 0) then\n\t\t\t\tdescriptors[statDescriptor[s]] = true\n\t\t\tend\n\t\telseif s ~= \"Type\" then\n\t\t\tmissing[1] = true\n\t\t\tmissing[s] = v\n\t\tend\n\tend\n\tlocal descOrdered = { }\n\tfor descriptor in pairs(descriptors) do\n\t\ttable.insert(descOrdered, descriptor)\n\tend\n\ttable.sort(descOrdered, function(a, b) return a.order < b.order end)\n\tfor _, descriptor in ipairs(descOrdered) do\n\t\tlocal val = { }\n\t\tfor i, s in ipairs(descriptor.stats) do\n\t\t\tval[i] = stats[s] or { min = 0, max = 0 }\n\t\t\tval[i].fmt = \"d\"\n\t\tend\n\t\tlocal desc = matchLimit(descriptor[1], val)\n\n\t\t-- Hack to handle ranges starting or ending at 0 where no descriptor is defined for 0\n\t\t-- Attempt to adapt existing ranges\n\t\tif not desc then\n\t\t\tfor _, s in ipairs(val) do\n\t\t\t\tif s.min == 0 and s.max > 0 then\n\t\t\t\t\ts.min = 1\n\t\t\t\t\ts.minZ = true\n\t\t\t\telseif s.min < 0 and s.max == 0 then\n\t\t\t\t\ts.max = -1\n\t\t\t\t\ts.maxZ = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tdesc = matchLimit(descriptor[1], val)\n\t\t\tfor _, s in ipairs(val) do\n\t\t\t\tif s.minZ then s.min = 0 end\n\t\t\t\tif s.maxZ then s.max = 0 end\n\t\t\tend\n\t\tend\n\n\t\tif desc then\n\t\t\tfor _, spec in ipairs(desc) do\n\t\t\t\tif spec.k == \"negate\" then\n\t\t\t\t\tval[spec.v].max, val[spec.v].min = -val[spec.v].min, -val[spec.v].max\n\t\t\t\telseif spec.k == \"invert_chance\" then\n\t\t\t\t\tval[spec.v].max, val[spec.v].min = 100 - val[spec.v].min, 100 - val[spec.v].max\n\t\t\t\telseif spec.k == \"negate_and_double\" then\n\t\t\t\t\tval[spec.v].max, val[spec.v].min = -2 * val[spec.v].min, -2 * val[spec.v].max\n\t\t\t\telseif spec.k == \"passive_hash\" then\n\t\t\t\t\t-- handled elsewhere\n\t\t\t\t\tif val[spec.v].min < 0 then\n\t\t\t\t\t\tval[spec.v].min = val[spec.v].min + 65536\n\t\t\t\t\t\tval[spec.v].max = val[spec.v].max + 65536\n\t\t\t\t\tend\n\t\t\t\telseif spec.k == \"divide_by_two_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 2)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 2)\n\t\t\t\telseif spec.k == \"divide_by_three\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 3\n\t\t\t\t\tval[spec.v].max = val[spec.v].min / 3\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_four\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 4\n\t\t\t\t\tval[spec.v].max = val[spec.v].min / 4\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_five\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 5\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 5\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_six\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 6\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 6\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_ten_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 10)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 10)\n\t\t\t\telseif spec.k == \"divide_by_ten_1dp\" or spec.k == \"divide_by_ten_1dp_if_required\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 10, 1)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 10, 1)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_twelve\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 12\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 12\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_fifteen_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 15)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 15)\n\t\t\t\telseif spec.k == \"divide_by_twenty\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 20\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 20\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_twenty_then_double_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 20) * 2\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 20) * 2\n\t\t\t\telseif spec.k == \"divide_by_fifty\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 50\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 50\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_hundred\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 100\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 100\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_hundred_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 100)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 100)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_hundred_1dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 100, 1)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 100, 1)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_hundred_2dp_if_required\" or spec.k == \"divide_by_one_hundred_2dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 100, 2)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 100, 2)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_hundred_and_negate\" then\n\t\t\t\t\tval[spec.v].min = -val[spec.v].min / 100\n\t\t\t\t\tval[spec.v].max = -val[spec.v].max / 100\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"divide_by_one_thousand\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 1000\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 1000\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"per_minute_to_per_second\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 60\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 60\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"per_minute_to_per_second_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 60)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 60)\n\t\t\t\telseif spec.k == \"per_minute_to_per_second_1dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 60, 1)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 60, 1)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"per_minute_to_per_second_2dp_if_required\" or spec.k == \"per_minute_to_per_second_2dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 60, 2)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 60, 2)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"milliseconds_to_seconds\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 1000\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 1000\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"milliseconds_to_seconds_halved\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 1000 / 2\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 1000 / 2\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"milliseconds_to_seconds_0dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 1000)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 1000)\n\t\t\t\telseif spec.k == \"milliseconds_to_seconds_1dp\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 1000, 1)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 1000, 1)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"milliseconds_to_seconds_2dp\" or spec.k == \"milliseconds_to_seconds_2dp_if_required\" then\n\t\t\t\t\tval[spec.v].min = round(val[spec.v].min / 1000, 2)\n\t\t\t\t\tval[spec.v].max = round(val[spec.v].max / 1000, 2)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\t\t\t\t\t\t\t\t\t\t\n\t\t\t\telseif spec.k == \"deciseconds_to_seconds\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min / 10\n\t\t\t\t\tval[spec.v].max = val[spec.v].max / 10\n\t\t\t\t\tval[spec.v].fmt = \".2f\"\n\t\t\t\telseif spec.k == \"30%_of_value\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 0.3\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 0.3\n\t\t\t\telseif spec.k == \"60%_of_value\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 0.6\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 0.6\n\t\t\t\telseif spec.k == \"mod_value_to_item_class\" then\n\t\t\t\t\tval[spec.v].min = ItemClasses[val[spec.v].min].Name\n\t\t\t\t\tval[spec.v].max = ItemClasses[val[spec.v].max].Name\n\t\t\t\t\tval[spec.v].fmt = \"s\"\n\t\t\t\telseif spec.k == \"multiplicative_damage_modifier\" then\n\t\t\t\t\tval[spec.v].min = 100 + val[spec.v].min\n\t\t\t\t\tval[spec.v].max = 100 + val[spec.v].max\n\t\t\t\telseif spec.k == \"multiplicative_permyriad_damage_modifier\" then\n\t\t\t\t\tval[spec.v].min = 100 + (val[spec.v].min / 100)\n\t\t\t\t\tval[spec.v].max = 100 + (val[spec.v].max / 100)\n\t\t\t\t\tval[spec.v].fmt = \"g\"\n\t\t\t\telseif spec.k == \"times_one_point_five\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 1.5\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 1.5\n\t\t\t\telseif spec.k == \"double\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 2\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 2\n\t\t\t\telseif spec.k == \"multiply_by_four\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 4\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 4\n\t\t\t\telseif spec.k == \"multiply_by_four_and_negate\" then\n\t\t\t\t\tval[spec.v].min = -val[spec.v].min * 4\n\t\t\t\t\tval[spec.v].max = -val[spec.v].max * 4\n\t\t\t\telseif spec.k == \"multiply_by_ten\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 10\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 10\n\t\t\t\telseif spec.k == \"times_twenty\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 20\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 20\n\t\t\t\telseif spec.k == \"multiply_by_one_hundred\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min * 100\n\t\t\t\t\tval[spec.v].max = val[spec.v].max * 100\n\t\t\t\telseif spec.k == \"plus_two_hundred\" then\n\t\t\t\t\tval[spec.v].min = val[spec.v].min + 200\n\t\t\t\t\tval[spec.v].max = val[spec.v].max + 200\n\t\t\t\telseif spec.k == \"reminderstring\" or spec.k == \"canonical_line\" or spec.k == \"canonical_stat\" then\n\t\t\t\telseif spec.k then\n\t\t\t\t\tConPrintf(\"Unknown description function: %s\", spec.k)\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal statDesc = desc.text:gsub(\"{(%d)}\", function(n) \n\t\t\t\tlocal v = val[tonumber(n)+1]\n\t\t\t\tif v.min == v.max then\n\t\t\t\t\treturn string.format(\"%\"..v.fmt, v.min)\n\t\t\t\telse\n\t\t\t\t\treturn string.format(\"(%\"..v.fmt..\"-%\"..v.fmt..\")\", v.min, v.max)\n\t\t\t\tend\n\t\t\tend):gsub(\"{}\", function() \n\t\t\t\tlocal v = val[1]\n\t\t\t\tif v.min == v.max then\n\t\t\t\t\treturn string.format(\"%\"..v.fmt, v.min)\n\t\t\t\telse\n\t\t\t\t\treturn string.format(\"(%\"..v.fmt..\"-%\"..v.fmt..\")\", v.min, v.max)\n\t\t\t\tend\n\t\t\tend):gsub(\"{(%d?):(%+?)d?}\", function(n, fmt)\n\t\t\t\t-- Most forms are {0:1}, however Chain Hook enchantment is {0:}\n\t\t\t\t-- the above pattern supports both cases.\n\t\t\t\tn = n ~= \"\" and n or \"0\"\n\t\t\t\tlocal v = val[tonumber(n)+1]\n\t\t\t\tif v.min == v.max then\n\t\t\t\t\treturn string.format(\"%\"..fmt..v.fmt, v.min)\n\t\t\t\telseif fmt == \"+\" then\n\t\t\t\t\tif v.max < 0 then\n\t\t\t\t\t\treturn string.format(\"-(%\" .. v.fmt .. \"-%\" .. v.fmt .. \")\", -v.min, -v.max)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn string.format(\"+(%\" .. v.fmt .. \"-%\" .. v.fmt .. \")\", v.min, v.max)\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\treturn string.format(\"(%\"..fmt..v.fmt..\"-%\"..fmt..v.fmt..\")\", v.min, v.max)\n\t\t\t\tend\n\t\t\tend):gsub(\"%%%%\",\"%%\")\n\t\t\tlocal order = descriptor.order\n\t\t\tfor line in (statDesc..\"\\\\n\"):gmatch(\"([^\\\\]+)\\\\n\") do\n\t\t\t\ttable.insert(out, sanitiseText(line))\n\t\t\t\ttable.insert(orders, order)\n\t\t\t\torder = order + 0.1\n\t\t\tend\n\t\tend\n\tend\n\treturn out, orders, missing\nend\n\nfunction describeMod(mod)\n\tlocal stats = { }\n\tfor i = 1, 6 do\n\t\tif mod[\"Stat\"..i] then\n\t\t\tstats[mod[\"Stat\"..i].Id] = { min = mod[\"Stat\"..i..\"Value\"][1], max = mod[\"Stat\"..i..\"Value\"][2] }\n\t\tend\n\tend\n\tif mod.Type then\n\t\tstats.Type = mod.Type\n\tend\n\tlocal out, orders, missing = describeStats(stats)\n\tout.modTags = describeModTags(mod.ImplicitTags)\n\treturn out, orders, missing\nend\n\nfunction describeScalability(fileName)\n\tlocal out = { }\n\tlocal stats = dat(\"stats\")\n\tfor stat, statDescription in pairs(statDescriptors[fileName]) do\n\t\tlocal scalability = { }\n\t\tif statDescription.stats then\n\t\t\tfor i, stat in ipairs(statDescription.stats) do\n\t\t\t\ttable.insert(scalability, stats:GetRow(\"Id\", stat).IsScalable)\n\t\t\tend\n\t\t\tfor _, wordings in ipairs(statDescription[1]) do\n\t\t\t\tlocal wordingFormats = {}\n\t\t\t\tlocal inOrderScalability = { }\n\t\t\t\tfor _, format in ipairs(wordings) do\n\t\t\t\t\tif type(format.v) == \"number\" then\n\t\t\t\t\t\tif wordingFormats[tonumber(format.v)] then\n\t\t\t\t\t\t\ttable.insert(wordingFormats[tonumber(format.v)],  format.k)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twordingFormats[tonumber(format.v)] = { format.k }\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tlocal strippedLine = wordings.text:gsub(\"[%+%-]?(%b{})\", function(num)\n\t\t\t\t\tlocal statNum = (num:match(\"%d\") or 0) + 1\n\t\t\t\t\ttable.insert(inOrderScalability, { isScalable = scalability[statNum], formats = wordingFormats[statNum] })\n\t\t\t\t\treturn \"#\"\n\t\t\t\tend)\n\t\t\t\tif out[strippedLine] then -- we want to use the format with the least oddities in it. If their are less formats then that will be used instead.\n\t\t\t\t\tfor j, priorScalability in ipairs(out[strippedLine]) do\n\t\t\t\t\t\tif (priorScalability.formats and #priorScalability.formats or 0) > (wordingFormats[j] and #wordingFormats[j] or 0) then \n\t\t\t\t\t\t\tout[strippedLine][j] = inOrderScalability[j]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\telse -- no present\n\t\t\t\t\tout[strippedLine] = inOrderScalability\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn out\nend\n"
}